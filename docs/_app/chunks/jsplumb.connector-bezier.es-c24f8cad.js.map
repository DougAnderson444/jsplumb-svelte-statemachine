{"version":3,"file":"jsplumb.connector-bezier.es-c24f8cad.js","sources":["../../../../../node_modules/@jsplumb/connector-bezier/js/jsplumb.connector-bezier.es.js"],"sourcesContent":["import { extend, log } from '@jsplumb/util';\nimport { ArcSegment, AbstractConnector, Connectors } from '@jsplumb/core';\nimport { AbstractSegment } from '@jsplumb/common';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar AbstractBezierConnector = function (_AbstractConnector) {\n  _inherits(AbstractBezierConnector, _AbstractConnector);\n  var _super = _createSuper(AbstractBezierConnector);\n  function AbstractBezierConnector(connection, params) {\n    var _this;\n    _classCallCheck(this, AbstractBezierConnector);\n    _this = _super.call(this, connection, params);\n    _this.connection = connection;\n    _defineProperty(_assertThisInitialized(_this), \"showLoopback\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"curviness\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"margin\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"proximityLimit\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"orientation\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"loopbackRadius\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"clockwise\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"isLoopbackCurrently\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"geometry\", void 0);\n    params = params || {};\n    _this.showLoopback = params.showLoopback !== false;\n    _this.curviness = params.curviness || 10;\n    _this.margin = params.margin || 5;\n    _this.proximityLimit = params.proximityLimit || 80;\n    _this.clockwise = params.orientation && params.orientation === \"clockwise\";\n    _this.loopbackRadius = params.loopbackRadius || 25;\n    _this.isLoopbackCurrently = false;\n    return _this;\n  }\n  _createClass(AbstractBezierConnector, [{\n    key: \"getDefaultStubs\",\n    value: function getDefaultStubs() {\n      return [0, 0];\n    }\n  }, {\n    key: \"_compute\",\n    value: function _compute(paintInfo, p) {\n      var sp = p.sourcePos,\n          tp = p.targetPos,\n          _w = Math.abs(sp.curX - tp.curX),\n          _h = Math.abs(sp.curY - tp.curY);\n      if (!this.showLoopback || p.sourceEndpoint.elementId !== p.targetEndpoint.elementId) {\n        this.isLoopbackCurrently = false;\n        this._computeBezier(paintInfo, p, sp, tp, _w, _h);\n      } else {\n        this.isLoopbackCurrently = true;\n        var x1 = p.sourcePos.curX,\n            y1 = p.sourcePos.curY - this.margin,\n            cx = x1,\n            cy = y1 - this.loopbackRadius,\n        _x = cx - this.loopbackRadius,\n            _y = cy - this.loopbackRadius;\n        _w = 2 * this.loopbackRadius;\n        _h = 2 * this.loopbackRadius;\n        paintInfo.points[0] = _x;\n        paintInfo.points[1] = _y;\n        paintInfo.points[2] = _w;\n        paintInfo.points[3] = _h;\n        this._addSegment(ArcSegment, {\n          loopback: true,\n          x1: x1 - _x + 4,\n          y1: y1 - _y,\n          startAngle: 0,\n          endAngle: 2 * Math.PI,\n          r: this.loopbackRadius,\n          ac: !this.clockwise,\n          x2: x1 - _x - 4,\n          y2: y1 - _y,\n          cx: cx - _x,\n          cy: cy - _y\n        });\n      }\n    }\n  }, {\n    key: \"exportGeometry\",\n    value: function exportGeometry() {\n      if (this.geometry == null) {\n        return null;\n      } else {\n        return {\n          controlPoints: [extend({}, this.geometry.controlPoints[0]), extend({}, this.geometry.controlPoints[1])],\n          source: extend({}, this.geometry.source),\n          target: extend({}, this.geometry.target)\n        };\n      }\n    }\n  }, {\n    key: \"transformGeometry\",\n    value: function transformGeometry(g, dx, dy) {\n      return {\n        controlPoints: [{\n          x: g.controlPoints[0].x + dx,\n          y: g.controlPoints[0].y + dy\n        }, {\n          x: g.controlPoints[1].x + dx,\n          y: g.controlPoints[1].y + dy\n        }],\n        source: this.transformAnchorPlacement(g.source, dx, dy),\n        target: this.transformAnchorPlacement(g.target, dx, dy)\n      };\n    }\n  }, {\n    key: \"importGeometry\",\n    value: function importGeometry(geometry) {\n      if (geometry != null) {\n        if (geometry.controlPoints == null || geometry.controlPoints.length != 2) {\n          log(\"jsPlumb Bezier: cannot import geometry; controlPoints missing or does not have length 2\");\n          this.setGeometry(null, true);\n          return false;\n        }\n        if (geometry.controlPoints[0].x == null || geometry.controlPoints[0].y == null || geometry.controlPoints[1].x == null || geometry.controlPoints[1].y == null) {\n          log(\"jsPlumb Bezier: cannot import geometry; controlPoints malformed\");\n          this.setGeometry(null, true);\n          return false;\n        }\n        if (geometry.source == null || geometry.source.curX == null || geometry.source.curY == null) {\n          log(\"jsPlumb Bezier: cannot import geometry; source missing or malformed\");\n          this.setGeometry(null, true);\n          return false;\n        }\n        if (geometry.target == null || geometry.target.curX == null || geometry.target.curY == null) {\n          log(\"jsPlumb Bezier: cannot import geometry; target missing or malformed\");\n          this.setGeometry(null, true);\n          return false;\n        }\n        this.setGeometry(geometry, false);\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }]);\n  return AbstractBezierConnector;\n}(AbstractConnector);\n\nvar Vectors = {\n  subtract: function subtract(v1, v2) {\n    return {\n      x: v1.x - v2.x,\n      y: v1.y - v2.y\n    };\n  },\n  dotProduct: function dotProduct(v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n  },\n  square: function square(v) {\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n  },\n  scale: function scale(v, s) {\n    return {\n      x: v.x * s,\n      y: v.y * s\n    };\n  }\n};\nvar maxRecursion = 64;\nvar flatnessTolerance = Math.pow(2.0, -maxRecursion - 1);\nfunction distanceFromCurve(point, curve) {\n  var candidates = [],\n      w = _convertToBezier(point, curve),\n      degree = curve.length - 1,\n      higherDegree = 2 * degree - 1,\n      numSolutions = _findRoots(w, higherDegree, candidates, 0),\n      v = Vectors.subtract(point, curve[0]),\n      dist = Vectors.square(v),\n      t = 0.0,\n      newDist;\n  for (var i = 0; i < numSolutions; i++) {\n    v = Vectors.subtract(point, _bezier(curve, degree, candidates[i], null, null));\n    newDist = Vectors.square(v);\n    if (newDist < dist) {\n      dist = newDist;\n      t = candidates[i];\n    }\n  }\n  v = Vectors.subtract(point, curve[degree]);\n  newDist = Vectors.square(v);\n  if (newDist < dist) {\n    dist = newDist;\n    t = 1.0;\n  }\n  return {\n    location: t,\n    distance: dist\n  };\n}\nfunction nearestPointOnCurve(point, curve) {\n  var td = distanceFromCurve(point, curve);\n  return {\n    point: _bezier(curve, curve.length - 1, td.location, null, null),\n    location: td.location\n  };\n}\nfunction _convertToBezier(point, curve) {\n  var degree = curve.length - 1,\n      higherDegree = 2 * degree - 1,\n      c = [],\n      d = [],\n      cdTable = [],\n      w = [],\n      z = [[1.0, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1.0]];\n  for (var i = 0; i <= degree; i++) {\n    c[i] = Vectors.subtract(curve[i], point);\n  }\n  for (var _i = 0; _i <= degree - 1; _i++) {\n    d[_i] = Vectors.subtract(curve[_i + 1], curve[_i]);\n    d[_i] = Vectors.scale(d[_i], 3.0);\n  }\n  for (var row = 0; row <= degree - 1; row++) {\n    for (var column = 0; column <= degree; column++) {\n      if (!cdTable[row]) cdTable[row] = [];\n      cdTable[row][column] = Vectors.dotProduct(d[row], c[column]);\n    }\n  }\n  for (var _i2 = 0; _i2 <= higherDegree; _i2++) {\n    if (!w[_i2]) {\n      w[_i2] = [];\n    }\n    w[_i2].y = 0.0;\n    w[_i2].x = parseFloat(\"\" + _i2) / higherDegree;\n  }\n  var n = degree,\n      m = degree - 1;\n  for (var k = 0; k <= n + m; k++) {\n    var lb = Math.max(0, k - m),\n        ub = Math.min(k, n);\n    for (var _i3 = lb; _i3 <= ub; _i3++) {\n      var j = k - _i3;\n      w[_i3 + j].y += cdTable[j][_i3] * z[j][_i3];\n    }\n  }\n  return w;\n}\nfunction _findRoots(w, degree, t, depth) {\n  var left = [],\n      right = [],\n      left_count,\n      right_count,\n      left_t = [],\n      right_t = [];\n  switch (_getCrossingCount(w, degree)) {\n    case 0:\n      {\n        return 0;\n      }\n    case 1:\n      {\n        if (depth >= maxRecursion) {\n          t[0] = (w[0].x + w[degree].x) / 2.0;\n          return 1;\n        }\n        if (_isFlatEnough(w, degree)) {\n          t[0] = _computeXIntercept(w, degree);\n          return 1;\n        }\n        break;\n      }\n  }\n  _bezier(w, degree, 0.5, left, right);\n  left_count = _findRoots(left, degree, left_t, depth + 1);\n  right_count = _findRoots(right, degree, right_t, depth + 1);\n  for (var i = 0; i < left_count; i++) {\n    t[i] = left_t[i];\n  }\n  for (var _i4 = 0; _i4 < right_count; _i4++) {\n    t[_i4 + left_count] = right_t[_i4];\n  }\n  return left_count + right_count;\n}\nfunction _getCrossingCount(curve, degree) {\n  var n_crossings = 0,\n      sign,\n      old_sign;\n  sign = old_sign = sgn(curve[0].y);\n  for (var i = 1; i <= degree; i++) {\n    sign = sgn(curve[i].y);\n    if (sign != old_sign) n_crossings++;\n    old_sign = sign;\n  }\n  return n_crossings;\n}\nfunction _isFlatEnough(curve, degree) {\n  var error, intercept_1, intercept_2, left_intercept, right_intercept, a, b, c, det, dInv, a1, b1, c1, a2, b2, c2;\n  a = curve[0].y - curve[degree].y;\n  b = curve[degree].x - curve[0].x;\n  c = curve[0].x * curve[degree].y - curve[degree].x * curve[0].y;\n  var max_distance_above, max_distance_below;\n  max_distance_above = max_distance_below = 0.0;\n  for (var i = 1; i < degree; i++) {\n    var value = a * curve[i].x + b * curve[i].y + c;\n    if (value > max_distance_above) {\n      max_distance_above = value;\n    } else if (value < max_distance_below) {\n      max_distance_below = value;\n    }\n  }\n  a1 = 0.0;\n  b1 = 1.0;\n  c1 = 0.0;\n  a2 = a;\n  b2 = b;\n  c2 = c - max_distance_above;\n  det = a1 * b2 - a2 * b1;\n  dInv = 1.0 / det;\n  intercept_1 = (b1 * c2 - b2 * c1) * dInv;\n  a2 = a;\n  b2 = b;\n  c2 = c - max_distance_below;\n  det = a1 * b2 - a2 * b1;\n  dInv = 1.0 / det;\n  intercept_2 = (b1 * c2 - b2 * c1) * dInv;\n  left_intercept = Math.min(intercept_1, intercept_2);\n  right_intercept = Math.max(intercept_1, intercept_2);\n  error = right_intercept - left_intercept;\n  return error < flatnessTolerance ? 1 : 0;\n}\nfunction _computeXIntercept(curve, degree) {\n  var XLK = 1.0,\n      YLK = 0.0,\n      XNM = curve[degree].x - curve[0].x,\n      YNM = curve[degree].y - curve[0].y,\n      XMK = curve[0].x - 0.0,\n      YMK = curve[0].y - 0.0,\n      det = XNM * YLK - YNM * XLK,\n      detInv = 1.0 / det,\n      S = (XNM * YMK - YNM * XMK) * detInv;\n  return 0.0 + XLK * S;\n}\nfunction _bezier(curve, degree, t, left, right) {\n  var temp = [[]];\n  for (var j = 0; j <= degree; j++) {\n    temp[0][j] = curve[j];\n  }\n  for (var i = 1; i <= degree; i++) {\n    for (var _j = 0; _j <= degree - i; _j++) {\n      if (!temp[i]) temp[i] = [];\n      if (!temp[i][_j]) temp[i][_j] = {};\n      temp[i][_j].x = (1.0 - t) * temp[i - 1][_j].x + t * temp[i - 1][_j + 1].x;\n      temp[i][_j].y = (1.0 - t) * temp[i - 1][_j].y + t * temp[i - 1][_j + 1].y;\n    }\n  }\n  if (left != null) {\n    for (var _j2 = 0; _j2 <= degree; _j2++) {\n      left[_j2] = temp[_j2][0];\n    }\n  }\n  if (right != null) {\n    for (var _j3 = 0; _j3 <= degree; _j3++) {\n      right[_j3] = temp[degree - _j3][_j3];\n    }\n  }\n  return temp[degree][0];\n}\nfunction _getLUT(steps, curve) {\n  var out = [];\n  steps--;\n  for (var n = 0; n <= steps; n++) {\n    out.push(_computeLookup(n / steps, curve));\n  }\n  return out;\n}\nfunction _computeLookup(e, curve) {\n  var EMPTY_POINT = {\n    x: 0,\n    y: 0\n  };\n  if (e === 0) {\n    return curve[0];\n  }\n  var degree = curve.length - 1;\n  if (e === 1) {\n    return curve[degree];\n  }\n  var o = curve;\n  var s = 1 - e;\n  if (degree === 0) {\n    return curve[0];\n  }\n  if (degree === 1) {\n    return {\n      x: s * o[0].x + e * o[1].x,\n      y: s * o[0].y + e * o[1].y\n    };\n  }\n  if (4 > degree) {\n    var l = s * s,\n        h = e * e,\n        u = 0,\n        m,\n        g,\n        f;\n    if (degree === 2) {\n      o = [o[0], o[1], o[2], EMPTY_POINT];\n      m = l;\n      g = 2 * (s * e);\n      f = h;\n    } else if (degree === 3) {\n      m = l * s;\n      g = 3 * (l * e);\n      f = 3 * (s * h);\n      u = e * h;\n    }\n    return {\n      x: m * o[0].x + g * o[1].x + f * o[2].x + u * o[3].x,\n      y: m * o[0].y + g * o[1].y + f * o[2].y + u * o[3].y\n    };\n  } else {\n    return EMPTY_POINT;\n  }\n}\nfunction computeBezierLength(curve) {\n  var length = 0;\n  if (!isPoint(curve)) {\n    var steps = 16;\n    var lut = _getLUT(steps, curve);\n    for (var i = 0; i < steps - 1; i++) {\n      var a = lut[i],\n          b = lut[i + 1];\n      length += dist(a, b);\n    }\n  }\n  return length;\n}\nvar _curveFunctionCache = new Map();\nfunction _getCurveFunctions(order) {\n  var fns = _curveFunctionCache.get(order);\n  if (!fns) {\n    fns = [];\n    var f_term = function f_term() {\n      return function (t) {\n        return Math.pow(t, order);\n      };\n    },\n        l_term = function l_term() {\n      return function (t) {\n        return Math.pow(1 - t, order);\n      };\n    },\n        c_term = function c_term(c) {\n      return function (t) {\n        return c;\n      };\n    },\n        t_term = function t_term() {\n      return function (t) {\n        return t;\n      };\n    },\n        one_minus_t_term = function one_minus_t_term() {\n      return function (t) {\n        return 1 - t;\n      };\n    },\n        _termFunc = function _termFunc(terms) {\n      return function (t) {\n        var p = 1;\n        for (var i = 0; i < terms.length; i++) {\n          p = p * terms[i](t);\n        }\n        return p;\n      };\n    };\n    fns.push(f_term());\n    for (var i = 1; i < order; i++) {\n      var terms = [c_term(order)];\n      for (var j = 0; j < order - i; j++) {\n        terms.push(t_term());\n      }\n      for (var _j4 = 0; _j4 < i; _j4++) {\n        terms.push(one_minus_t_term());\n      }\n      fns.push(_termFunc(terms));\n    }\n    fns.push(l_term());\n    _curveFunctionCache.set(order, fns);\n  }\n  return fns;\n}\nfunction pointOnCurve(curve, location) {\n  var cc = _getCurveFunctions(curve.length - 1),\n      _x = 0,\n      _y = 0;\n  for (var i = 0; i < curve.length; i++) {\n    _x = _x + curve[i].x * cc[i](location);\n    _y = _y + curve[i].y * cc[i](location);\n  }\n  return {\n    x: _x,\n    y: _y\n  };\n}\nfunction dist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n}\nfunction isPoint(curve) {\n  return curve[0].x === curve[1].x && curve[0].y === curve[1].y;\n}\nfunction pointAlongPath(curve, location, distance) {\n  if (isPoint(curve)) {\n    return {\n      point: curve[0],\n      location: location\n    };\n  }\n  var prev = pointOnCurve(curve, location),\n      tally = 0,\n      curLoc = location,\n      direction = distance > 0 ? 1 : -1,\n      cur = null;\n  while (tally < Math.abs(distance)) {\n    curLoc += 0.005 * direction;\n    cur = pointOnCurve(curve, curLoc);\n    tally += dist(cur, prev);\n    prev = cur;\n  }\n  return {\n    point: cur,\n    location: curLoc\n  };\n}\nfunction pointAlongCurveFrom(curve, location, distance) {\n  return pointAlongPath(curve, location, distance).point;\n}\nfunction locationAlongCurveFrom(curve, location, distance) {\n  return pointAlongPath(curve, location, distance).location;\n}\nfunction gradientAtPoint(curve, location) {\n  var p1 = pointOnCurve(curve, location),\n      p2 = pointOnCurve(curve.slice(0, curve.length - 1), location),\n      dy = p2.y - p1.y,\n      dx = p2.x - p1.x;\n  return dy === 0 ? Infinity : Math.atan(dy / dx);\n}\nfunction gradientAtPointAlongPathFrom(curve, location, distance) {\n  var p = pointAlongPath(curve, location, distance);\n  if (p.location > 1) p.location = 1;\n  if (p.location < 0) p.location = 0;\n  return gradientAtPoint(curve, p.location);\n}\nfunction perpendicularToPathAt(curve, location, length, distance) {\n  distance = distance == null ? 0 : distance;\n  var p = pointAlongPath(curve, location, distance),\n      m = gradientAtPoint(curve, p.location),\n      _theta2 = Math.atan(-1 / m),\n      y = length / 2 * Math.sin(_theta2),\n      x = length / 2 * Math.cos(_theta2);\n  return [{\n    x: p.point.x + x,\n    y: p.point.y + y\n  }, {\n    x: p.point.x - x,\n    y: p.point.y - y\n  }];\n}\nfunction bezierLineIntersection(x1, y1, x2, y2, curve) {\n  var a = y2 - y1,\n      b = x1 - x2,\n      c = x1 * (y1 - y2) + y1 * (x2 - x1),\n      coeffs = _computeCoefficients(curve),\n      p = [a * coeffs[0][0] + b * coeffs[1][0], a * coeffs[0][1] + b * coeffs[1][1], a * coeffs[0][2] + b * coeffs[1][2], a * coeffs[0][3] + b * coeffs[1][3] + c],\n      r = _cubicRoots.apply(null, p),\n      intersections = [];\n  if (r != null) {\n    for (var i = 0; i < 3; i++) {\n      var _t = r[i],\n          t2 = Math.pow(_t, 2),\n          t3 = Math.pow(_t, 3),\n          x = {\n        x: coeffs[0][0] * t3 + coeffs[0][1] * t2 + coeffs[0][2] * _t + coeffs[0][3],\n        y: coeffs[1][0] * t3 + coeffs[1][1] * t2 + coeffs[1][2] * _t + coeffs[1][3]\n      };\n      var s = void 0;\n      if (x2 - x1 !== 0) {\n        s = (x[0] - x1) / (x2 - x1);\n      } else {\n        s = (x[1] - y1) / (y2 - y1);\n      }\n      if (_t >= 0 && _t <= 1.0 && s >= 0 && s <= 1.0) {\n        intersections.push(x);\n      }\n    }\n  }\n  return intersections;\n}\nfunction boxIntersection(x, y, w, h, curve) {\n  var i = [];\n  i.push.apply(i, bezierLineIntersection(x, y, x + w, y, curve));\n  i.push.apply(i, bezierLineIntersection(x + w, y, x + w, y + h, curve));\n  i.push.apply(i, bezierLineIntersection(x + w, y + h, x, y + h, curve));\n  i.push.apply(i, bezierLineIntersection(x, y + h, x, y, curve));\n  return i;\n}\nfunction boundingBoxIntersection(boundingBox, curve) {\n  var i = [];\n  i.push.apply(i, bezierLineIntersection(boundingBox.x, boundingBox.y, boundingBox.x + boundingBox.w, boundingBox.y, curve));\n  i.push.apply(i, bezierLineIntersection(boundingBox.x + boundingBox.w, boundingBox.y, boundingBox.x + boundingBox.w, boundingBox.y + boundingBox.h, curve));\n  i.push.apply(i, bezierLineIntersection(boundingBox.x + boundingBox.w, boundingBox.y + boundingBox.h, boundingBox.x, boundingBox.y + boundingBox.h, curve));\n  i.push.apply(i, bezierLineIntersection(boundingBox.x, boundingBox.y + boundingBox.h, boundingBox.x, boundingBox.y, curve));\n  return i;\n}\nfunction _computeCoefficientsForAxis(curve, axis) {\n  return [-curve[0][axis] + 3 * curve[1][axis] + -3 * curve[2][axis] + curve[3][axis], 3 * curve[0][axis] - 6 * curve[1][axis] + 3 * curve[2][axis], -3 * curve[0][axis] + 3 * curve[1][axis], curve[0][axis]];\n}\nfunction _computeCoefficients(curve) {\n  return [_computeCoefficientsForAxis(curve, \"x\"), _computeCoefficientsForAxis(curve, \"y\")];\n}\nfunction sgn(x) {\n  return x < 0 ? -1 : x > 0 ? 1 : 0;\n}\nfunction _cubicRoots(a, b, c, d) {\n  var A = b / a,\n      B = c / a,\n      C = d / a,\n      Q = (3 * B - Math.pow(A, 2)) / 9,\n      R = (9 * A * B - 27 * C - 2 * Math.pow(A, 3)) / 54,\n      D = Math.pow(Q, 3) + Math.pow(R, 2),\n      S,\n      T,\n      t = [0, 0, 0];\n  if (D >= 0)\n    {\n      S = sgn(R + Math.sqrt(D)) * Math.pow(Math.abs(R + Math.sqrt(D)), 1 / 3);\n      T = sgn(R - Math.sqrt(D)) * Math.pow(Math.abs(R - Math.sqrt(D)), 1 / 3);\n      t[0] = -A / 3 + (S + T);\n      t[1] = -A / 3 - (S + T) / 2;\n      t[2] = -A / 3 - (S + T) / 2;\n      if (Math.abs(Math.sqrt(3) * (S - T) / 2) !== 0) {\n        t[1] = -1;\n        t[2] = -1;\n      }\n    } else\n    {\n      var th = Math.acos(R / Math.sqrt(-Math.pow(Q, 3)));\n      t[0] = 2 * Math.sqrt(-Q) * Math.cos(th / 3) - A / 3;\n      t[1] = 2 * Math.sqrt(-Q) * Math.cos((th + 2 * Math.PI) / 3) - A / 3;\n      t[2] = 2 * Math.sqrt(-Q) * Math.cos((th + 4 * Math.PI) / 3) - A / 3;\n    }\n  for (var i = 0; i < 3; i++) {\n    if (t[i] < 0 || t[i] > 1.0) {\n      t[i] = -1;\n    }\n  }\n  return t;\n}\n\nvar BezierSegment = function (_AbstractSegment) {\n  _inherits(BezierSegment, _AbstractSegment);\n  var _super = _createSuper(BezierSegment);\n  function BezierSegment(params) {\n    var _this;\n    _classCallCheck(this, BezierSegment);\n    _this = _super.call(this, params);\n    _defineProperty(_assertThisInitialized(_this), \"curve\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"cp1x\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"cp1y\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"cp2x\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"cp2y\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"length\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"type\", BezierSegment.segmentType);\n    _this.cp1x = params.cp1x;\n    _this.cp1y = params.cp1y;\n    _this.cp2x = params.cp2x;\n    _this.cp2y = params.cp2y;\n    _this.x1 = params.x1;\n    _this.x2 = params.x2;\n    _this.y1 = params.y1;\n    _this.y2 = params.y2;\n    _this.curve = [{\n      x: _this.x1,\n      y: _this.y1\n    }, {\n      x: _this.cp1x,\n      y: _this.cp1y\n    }, {\n      x: _this.cp2x,\n      y: _this.cp2y\n    }, {\n      x: _this.x2,\n      y: _this.y2\n    }];\n    _this.extents = {\n      xmin: Math.min(_this.x1, _this.x2, _this.cp1x, _this.cp2x),\n      ymin: Math.min(_this.y1, _this.y2, _this.cp1y, _this.cp2y),\n      xmax: Math.max(_this.x1, _this.x2, _this.cp1x, _this.cp2x),\n      ymax: Math.max(_this.y1, _this.y2, _this.cp1y, _this.cp2y)\n    };\n    return _this;\n  }\n  _createClass(BezierSegment, [{\n    key: \"getPath\",\n    value: function getPath(isFirstSegment) {\n      return (isFirstSegment ? \"M \" + this.x2 + \" \" + this.y2 + \" \" : \"\") + \"C \" + this.cp2x + \" \" + this.cp2y + \" \" + this.cp1x + \" \" + this.cp1y + \" \" + this.x1 + \" \" + this.y1;\n    }\n  }, {\n    key: \"pointOnPath\",\n    value: function pointOnPath(location, absolute) {\n      location = BezierSegment._translateLocation(this.curve, location, absolute);\n      return pointOnCurve(this.curve, location);\n    }\n  }, {\n    key: \"gradientAtPoint\",\n    value: function gradientAtPoint$1(location, absolute) {\n      location = BezierSegment._translateLocation(this.curve, location, absolute);\n      return gradientAtPoint(this.curve, location);\n    }\n  }, {\n    key: \"pointAlongPathFrom\",\n    value: function pointAlongPathFrom(location, distance, absolute) {\n      location = BezierSegment._translateLocation(this.curve, location, absolute);\n      return pointAlongCurveFrom(this.curve, location, distance);\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      if (this.length == null || this.length === 0) {\n        this.length = computeBezierLength(this.curve);\n      }\n      return this.length;\n    }\n  }, {\n    key: \"findClosestPointOnPath\",\n    value: function findClosestPointOnPath(x, y) {\n      var p = nearestPointOnCurve({\n        x: x,\n        y: y\n      }, this.curve);\n      return {\n        d: Math.sqrt(Math.pow(p.point.x - x, 2) + Math.pow(p.point.y - y, 2)),\n        x: p.point.x,\n        y: p.point.y,\n        l: 1 - p.location,\n        s: this,\n        x1: null,\n        y1: null,\n        x2: null,\n        y2: null\n      };\n    }\n  }, {\n    key: \"lineIntersection\",\n    value: function lineIntersection(x1, y1, x2, y2) {\n      return bezierLineIntersection(x1, y1, x2, y2, this.curve);\n    }\n  }], [{\n    key: \"_translateLocation\",\n    value: function _translateLocation(_curve, location, absolute) {\n      if (absolute) {\n        location = locationAlongCurveFrom(_curve, location > 0 ? 0 : 1, location);\n      }\n      return location;\n    }\n  }]);\n  return BezierSegment;\n}(AbstractSegment);\n_defineProperty(BezierSegment, \"segmentType\", \"Bezier\");\n\nvar BezierConnector = function (_AbstractBezierConnec) {\n  _inherits(BezierConnector, _AbstractBezierConnec);\n  var _super = _createSuper(BezierConnector);\n  function BezierConnector(connection, params) {\n    var _this;\n    _classCallCheck(this, BezierConnector);\n    _this = _super.call(this, connection, params);\n    _this.connection = connection;\n    _defineProperty(_assertThisInitialized(_this), \"type\", BezierConnector.type);\n    _defineProperty(_assertThisInitialized(_this), \"majorAnchor\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"minorAnchor\", void 0);\n    params = params || {};\n    _this.majorAnchor = params.curviness || 150;\n    _this.minorAnchor = 10;\n    return _this;\n  }\n  _createClass(BezierConnector, [{\n    key: \"getCurviness\",\n    value: function getCurviness() {\n      return this.majorAnchor;\n    }\n  }, {\n    key: \"_findControlPoint\",\n    value: function _findControlPoint(point, sourceAnchorPosition, targetAnchorPosition, soo, too) {\n      var perpendicular = soo[0] !== too[0] || soo[1] === too[1],\n          p = {\n        x: 0,\n        y: 0\n      };\n      if (!perpendicular) {\n        if (soo[0] === 0) {\n          p.x = sourceAnchorPosition.curX < targetAnchorPosition.curX ? point.x + this.minorAnchor : point.x - this.minorAnchor;\n        } else {\n          p.x = point.x - this.majorAnchor * soo[0];\n        }\n        if (soo[1] === 0) {\n          p.y = sourceAnchorPosition.curY < targetAnchorPosition.curY ? point.y + this.minorAnchor : point.y - this.minorAnchor;\n        } else {\n          p.y = point.y + this.majorAnchor * too[1];\n        }\n      } else {\n        if (too[0] === 0) {\n          p.x = targetAnchorPosition.curX < sourceAnchorPosition.curX ? point.x + this.minorAnchor : point.x - this.minorAnchor;\n        } else {\n          p.x = point.x + this.majorAnchor * too[0];\n        }\n        if (too[1] === 0) {\n          p.y = targetAnchorPosition.curY < sourceAnchorPosition.curY ? point.y + this.minorAnchor : point.y - this.minorAnchor;\n        } else {\n          p.y = point.y + this.majorAnchor * soo[1];\n        }\n      }\n      return p;\n    }\n  }, {\n    key: \"_computeBezier\",\n    value: function _computeBezier(paintInfo, p, sp, tp, _w, _h) {\n      var _CP,\n          _CP2,\n          _sx = sp.curX < tp.curX ? _w : 0,\n          _sy = sp.curY < tp.curY ? _h : 0,\n          _tx = sp.curX < tp.curX ? 0 : _w,\n          _ty = sp.curY < tp.curY ? 0 : _h;\n      if (this.edited !== true) {\n        _CP = this._findControlPoint({\n          x: _sx,\n          y: _sy\n        }, sp, tp, paintInfo.so, paintInfo.to);\n        _CP2 = this._findControlPoint({\n          x: _tx,\n          y: _ty\n        }, tp, sp, paintInfo.to, paintInfo.so);\n      } else {\n        _CP = this.geometry.controlPoints[0];\n        _CP2 = this.geometry.controlPoints[1];\n      }\n      this.geometry = {\n        controlPoints: [_CP, _CP2],\n        source: p.sourcePos,\n        target: p.targetPos\n      };\n      this._addSegment(BezierSegment, {\n        x1: _sx,\n        y1: _sy,\n        x2: _tx,\n        y2: _ty,\n        cp1x: _CP.x,\n        cp1y: _CP.y,\n        cp2x: _CP2.x,\n        cp2y: _CP2.y\n      });\n    }\n  }]);\n  return BezierConnector;\n}(AbstractBezierConnector);\n_defineProperty(BezierConnector, \"type\", \"Bezier\");\n\nfunction _segment(x1, y1, x2, y2) {\n  if (x1 <= x2 && y2 <= y1) {\n    return 1;\n  } else if (x1 <= x2 && y1 <= y2) {\n    return 2;\n  } else if (x2 <= x1 && y2 >= y1) {\n    return 3;\n  }\n  return 4;\n}\nfunction _findControlPoint(midx, midy, segment, sourceEdge, targetEdge, dx, dy, distance, proximityLimit) {\n  if (distance <= proximityLimit) {\n    return {\n      x: midx,\n      y: midy\n    };\n  }\n  if (segment === 1) {\n    if (sourceEdge.curY <= 0 && targetEdge.curY >= 1) {\n      return {\n        x: midx + (sourceEdge.x < 0.5 ? -1 * dx : dx),\n        y: midy\n      };\n    } else if (sourceEdge.curX >= 1 && targetEdge.curX <= 0) {\n      return {\n        x: midx,\n        y: midy + (sourceEdge.y < 0.5 ? -1 * dy : dy)\n      };\n    } else {\n      return {\n        x: midx + -1 * dx,\n        y: midy + -1 * dy\n      };\n    }\n  } else if (segment === 2) {\n    if (sourceEdge.curY >= 1 && targetEdge.curY <= 0) {\n      return {\n        x: midx + (sourceEdge.x < 0.5 ? -1 * dx : dx),\n        y: midy\n      };\n    } else if (sourceEdge.curX >= 1 && targetEdge.curX <= 0) {\n      return {\n        x: midx,\n        y: midy + (sourceEdge.y < 0.5 ? -1 * dy : dy)\n      };\n    } else {\n      return {\n        x: midx + dx,\n        y: midy + -1 * dy\n      };\n    }\n  } else if (segment === 3) {\n    if (sourceEdge.curY >= 1 && targetEdge.curY <= 0) {\n      return {\n        x: midx + (sourceEdge.x < 0.5 ? -1 * dx : dx),\n        y: midy\n      };\n    } else if (sourceEdge.curX <= 0 && targetEdge.curX >= 1) {\n      return {\n        x: midx,\n        y: midy + (sourceEdge.y < 0.5 ? -1 * dy : dy)\n      };\n    } else {\n      return {\n        x: midx + -1 * dx,\n        y: midy + -1 * dy\n      };\n    }\n  } else if (segment === 4) {\n    if (sourceEdge.curY <= 0 && targetEdge.curY >= 1) {\n      return {\n        x: midx + (sourceEdge.x < 0.5 ? -1 * dx : dx),\n        y: midy\n      };\n    } else if (sourceEdge.curX <= 0 && targetEdge.curX >= 1) {\n      return {\n        x: midx,\n        y: midy + (sourceEdge.y < 0.5 ? -1 * dy : dy)\n      };\n    } else {\n      return {\n        x: midx + dx,\n        y: midy + -1 * dy\n      };\n    }\n  }\n}\nvar StateMachineConnector = function (_AbstractBezierConnec) {\n  _inherits(StateMachineConnector, _AbstractBezierConnec);\n  var _super = _createSuper(StateMachineConnector);\n  function StateMachineConnector(connection, params) {\n    var _this;\n    _classCallCheck(this, StateMachineConnector);\n    _this = _super.call(this, connection, params);\n    _this.connection = connection;\n    _defineProperty(_assertThisInitialized(_this), \"type\", StateMachineConnector.type);\n    _defineProperty(_assertThisInitialized(_this), \"_controlPoint\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"proximityLimit\", void 0);\n    _this.curviness = params.curviness || 10;\n    _this.margin = params.margin || 5;\n    _this.proximityLimit = params.proximityLimit || 80;\n    _this.clockwise = params.orientation && params.orientation === \"clockwise\";\n    return _this;\n  }\n  _createClass(StateMachineConnector, [{\n    key: \"_computeBezier\",\n    value: function _computeBezier(paintInfo, params, sp, tp, w, h) {\n      var _sx = sp.curX < tp.curX ? 0 : w,\n          _sy = sp.curY < tp.curY ? 0 : h,\n          _tx = sp.curX < tp.curX ? w : 0,\n          _ty = sp.curY < tp.curY ? h : 0;\n      if (sp.x === 0) {\n        _sx -= this.margin;\n      }\n      if (sp.x === 1) {\n        _sx += this.margin;\n      }\n      if (sp.y === 0) {\n        _sy -= this.margin;\n      }\n      if (sp.y === 1) {\n        _sy += this.margin;\n      }\n      if (tp.x === 0) {\n        _tx -= this.margin;\n      }\n      if (tp.x === 1) {\n        _tx += this.margin;\n      }\n      if (tp.y === 0) {\n        _ty -= this.margin;\n      }\n      if (tp.y === 1) {\n        _ty += this.margin;\n      }\n      if (this.edited !== true) {\n        var _midx = (_sx + _tx) / 2,\n            _midy = (_sy + _ty) / 2,\n            segment = _segment(_sx, _sy, _tx, _ty),\n            distance = Math.sqrt(Math.pow(_tx - _sx, 2) + Math.pow(_ty - _sy, 2));\n        this._controlPoint = _findControlPoint(_midx, _midy, segment, params.sourcePos, params.targetPos, this.curviness, this.curviness, distance, this.proximityLimit);\n      } else {\n        this._controlPoint = this.geometry.controlPoints[0];\n      }\n      var cp1x, cp2x, cp1y, cp2y;\n      cp1x = this._controlPoint.x;\n      cp2x = this._controlPoint.x;\n      cp1y = this._controlPoint.y;\n      cp2y = this._controlPoint.y;\n      this.geometry = {\n        controlPoints: [this._controlPoint, this._controlPoint],\n        source: params.sourcePos,\n        target: params.targetPos\n      };\n      this._addSegment(BezierSegment, {\n        x1: _tx,\n        y1: _ty,\n        x2: _sx,\n        y2: _sy,\n        cp1x: cp1x,\n        cp1y: cp1y,\n        cp2x: cp2x,\n        cp2y: cp2y\n      });\n    }\n  }]);\n  return StateMachineConnector;\n}(AbstractBezierConnector);\n_defineProperty(StateMachineConnector, \"type\", \"StateMachine\");\n\nConnectors.register(BezierConnector.type, BezierConnector);\nConnectors.register(StateMachineConnector.type, StateMachineConnector);\n\nexport { AbstractBezierConnector, BezierConnector, BezierSegment, StateMachineConnector, bezierLineIntersection, boundingBoxIntersection, boxIntersection, computeBezierLength, dist, distanceFromCurve, gradientAtPoint, gradientAtPointAlongPathFrom, isPoint, locationAlongCurveFrom, nearestPointOnCurve, perpendicularToPathAt, pointAlongCurveFrom, pointAlongPath, pointOnCurve };\n"],"names":[],"mappings":";;AAIA,yBAAyB,UAAU,aAAa;AAC9C,MAAI,CAAE,qBAAoB,cAAc;AACtC,UAAM,IAAI,UAAU;AAAA;AAAA;AAIxB,2BAA2B,QAAQ,OAAO;AACxC,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,QAAI,aAAa,MAAM;AACvB,eAAW,aAAa,WAAW,cAAc;AACjD,eAAW,eAAe;AAC1B,QAAI,WAAW;AAAY,iBAAW,WAAW;AACjD,WAAO,eAAe,QAAQ,WAAW,KAAK;AAAA;AAAA;AAIlD,sBAAsB,aAAa,YAAY,aAAa;AAC1D,MAAI;AAAY,sBAAkB,YAAY,WAAW;AACzD,MAAI;AAAa,sBAAkB,aAAa;AAChD,SAAO;AAAA;AAGT,yBAAyB,KAAK,KAAK,OAAO;AACxC,MAAI,OAAO,KAAK;AACd,WAAO,eAAe,KAAK,KAAK;AAAA,MAC9B;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA;AAAA,SAEP;AACL,QAAI,OAAO;AAAA;AAGb,SAAO;AAAA;AAGT,mBAAmB,UAAU,YAAY;AACvC,MAAI,OAAO,eAAe,cAAc,eAAe,MAAM;AAC3D,UAAM,IAAI,UAAU;AAAA;AAGtB,WAAS,YAAY,OAAO,OAAO,cAAc,WAAW,WAAW;AAAA,IACrE,aAAa;AAAA,MACX,OAAO;AAAA,MACP,UAAU;AAAA,MACV,cAAc;AAAA;AAAA;AAGlB,MAAI;AAAY,oBAAgB,UAAU;AAAA;AAG5C,yBAAyB,GAAG;AAC1B,oBAAkB,OAAO,iBAAiB,OAAO,iBAAiB,0BAAyB,IAAG;AAC5F,WAAO,GAAE,aAAa,OAAO,eAAe;AAAA;AAE9C,SAAO,gBAAgB;AAAA;AAGzB,yBAAyB,GAAG,GAAG;AAC7B,oBAAkB,OAAO,kBAAkB,0BAAyB,IAAG,IAAG;AACxE,OAAE,YAAY;AACd,WAAO;AAAA;AAGT,SAAO,gBAAgB,GAAG;AAAA;AAG5B,qCAAqC;AACnC,MAAI,OAAO,YAAY,eAAe,CAAC,QAAQ;AAAW,WAAO;AACjE,MAAI,QAAQ,UAAU;AAAM,WAAO;AACnC,MAAI,OAAO,UAAU;AAAY,WAAO;AAExC,MAAI;AACF,YAAQ,UAAU,QAAQ,KAAK,QAAQ,UAAU,SAAS,IAAI,WAAY;AAAA;AAC1E,WAAO;AAAA,WACA,GAAP;AACA,WAAO;AAAA;AAAA;AAIX,gCAAgC,MAAM;AACpC,MAAI,SAAS,QAAQ;AACnB,UAAM,IAAI,eAAe;AAAA;AAG3B,SAAO;AAAA;AAGT,oCAAoC,MAAM,MAAM;AAC9C,MAAI,QAAS,QAAO,SAAS,YAAY,OAAO,SAAS,aAAa;AACpE,WAAO;AAAA;AAGT,SAAO,uBAAuB;AAAA;AAGhC,sBAAsB,SAAS;AAC7B,MAAI,4BAA4B;AAEhC,SAAO,gCAAgC;AACrC,QAAI,QAAQ,gBAAgB,UACxB;AAEJ,QAAI,2BAA2B;AAC7B,UAAI,YAAY,gBAAgB,MAAM;AAEtC,eAAS,QAAQ,UAAU,OAAO,WAAW;AAAA,WACxC;AACL,eAAS,MAAM,MAAM,MAAM;AAAA;AAG7B,WAAO,2BAA2B,MAAM;AAAA;AAAA;AAIzC,IAAC,0BAA0B,SAAU,oBAAoB;AAC1D,YAAU,0BAAyB;AACnC,MAAI,SAAS,aAAa;AAC1B,oCAAiC,YAAY,QAAQ;AACnD,QAAI;AACJ,oBAAgB,MAAM;AACtB,YAAQ,OAAO,KAAK,MAAM,YAAY;AACtC,UAAM,aAAa;AACnB,oBAAgB,uBAAuB,QAAQ,gBAAgB;AAC/D,oBAAgB,uBAAuB,QAAQ,aAAa;AAC5D,oBAAgB,uBAAuB,QAAQ,UAAU;AACzD,oBAAgB,uBAAuB,QAAQ,kBAAkB;AACjE,oBAAgB,uBAAuB,QAAQ,eAAe;AAC9D,oBAAgB,uBAAuB,QAAQ,kBAAkB;AACjE,oBAAgB,uBAAuB,QAAQ,aAAa;AAC5D,oBAAgB,uBAAuB,QAAQ,uBAAuB;AACtE,oBAAgB,uBAAuB,QAAQ,YAAY;AAC3D,aAAS,UAAU;AACnB,UAAM,eAAe,OAAO,iBAAiB;AAC7C,UAAM,YAAY,OAAO,aAAa;AACtC,UAAM,SAAS,OAAO,UAAU;AAChC,UAAM,iBAAiB,OAAO,kBAAkB;AAChD,UAAM,YAAY,OAAO,eAAe,OAAO,gBAAgB;AAC/D,UAAM,iBAAiB,OAAO,kBAAkB;AAChD,UAAM,sBAAsB;AAC5B,WAAO;AAAA;AAET,eAAa,0BAAyB,CAAC;AAAA,IACrC,KAAK;AAAA,IACL,OAAO,2BAA2B;AAChC,aAAO,CAAC,GAAG;AAAA;AAAA,KAEZ;AAAA,IACD,KAAK;AAAA,IACL,OAAO,kBAAkB,WAAW,GAAG;AACrC,UAAI,KAAK,EAAE,WACP,KAAK,EAAE,WACP,KAAK,KAAK,IAAI,GAAG,OAAO,GAAG,OAC3B,KAAK,KAAK,IAAI,GAAG,OAAO,GAAG;AAC/B,UAAI,CAAC,KAAK,gBAAgB,EAAE,eAAe,cAAc,EAAE,eAAe,WAAW;AACnF,aAAK,sBAAsB;AAC3B,aAAK,eAAe,WAAW,GAAG,IAAI,IAAI,IAAI;AAAA,aACzC;AACL,aAAK,sBAAsB;AAC3B,YAAI,KAAK,EAAE,UAAU,MACjB,KAAK,EAAE,UAAU,OAAO,KAAK,QAC7B,KAAK,IACL,KAAK,KAAK,KAAK,gBACnB,KAAK,KAAK,KAAK,gBACX,KAAK,KAAK,KAAK;AACnB,aAAK,IAAI,KAAK;AACd,aAAK,IAAI,KAAK;AACd,kBAAU,OAAO,KAAK;AACtB,kBAAU,OAAO,KAAK;AACtB,kBAAU,OAAO,KAAK;AACtB,kBAAU,OAAO,KAAK;AACtB,aAAK,YAAY,YAAY;AAAA,UAC3B,UAAU;AAAA,UACV,IAAI,KAAK,KAAK;AAAA,UACd,IAAI,KAAK;AAAA,UACT,YAAY;AAAA,UACZ,UAAU,IAAI,KAAK;AAAA,UACnB,GAAG,KAAK;AAAA,UACR,IAAI,CAAC,KAAK;AAAA,UACV,IAAI,KAAK,KAAK;AAAA,UACd,IAAI,KAAK;AAAA,UACT,IAAI,KAAK;AAAA,UACT,IAAI,KAAK;AAAA;AAAA;AAAA;AAAA,KAId;AAAA,IACD,KAAK;AAAA,IACL,OAAO,0BAA0B;AAC/B,UAAI,KAAK,YAAY,MAAM;AACzB,eAAO;AAAA,aACF;AACL,eAAO;AAAA,UACL,eAAe,CAAC,OAAO,IAAI,KAAK,SAAS,cAAc,KAAK,OAAO,IAAI,KAAK,SAAS,cAAc;AAAA,UACnG,QAAQ,OAAO,IAAI,KAAK,SAAS;AAAA,UACjC,QAAQ,OAAO,IAAI,KAAK,SAAS;AAAA;AAAA;AAAA;AAAA,KAItC;AAAA,IACD,KAAK;AAAA,IACL,OAAO,2BAA2B,GAAG,IAAI,IAAI;AAC3C,aAAO;AAAA,QACL,eAAe,CAAC;AAAA,UACd,GAAG,EAAE,cAAc,GAAG,IAAI;AAAA,UAC1B,GAAG,EAAE,cAAc,GAAG,IAAI;AAAA,WACzB;AAAA,UACD,GAAG,EAAE,cAAc,GAAG,IAAI;AAAA,UAC1B,GAAG,EAAE,cAAc,GAAG,IAAI;AAAA;AAAA,QAE5B,QAAQ,KAAK,yBAAyB,EAAE,QAAQ,IAAI;AAAA,QACpD,QAAQ,KAAK,yBAAyB,EAAE,QAAQ,IAAI;AAAA;AAAA;AAAA,KAGvD;AAAA,IACD,KAAK;AAAA,IACL,OAAO,wBAAwB,UAAU;AACvC,UAAI,YAAY,MAAM;AACpB,YAAI,SAAS,iBAAiB,QAAQ,SAAS,cAAc,UAAU,GAAG;AACxE,cAAI;AACJ,eAAK,YAAY,MAAM;AACvB,iBAAO;AAAA;AAET,YAAI,SAAS,cAAc,GAAG,KAAK,QAAQ,SAAS,cAAc,GAAG,KAAK,QAAQ,SAAS,cAAc,GAAG,KAAK,QAAQ,SAAS,cAAc,GAAG,KAAK,MAAM;AAC5J,cAAI;AACJ,eAAK,YAAY,MAAM;AACvB,iBAAO;AAAA;AAET,YAAI,SAAS,UAAU,QAAQ,SAAS,OAAO,QAAQ,QAAQ,SAAS,OAAO,QAAQ,MAAM;AAC3F,cAAI;AACJ,eAAK,YAAY,MAAM;AACvB,iBAAO;AAAA;AAET,YAAI,SAAS,UAAU,QAAQ,SAAS,OAAO,QAAQ,QAAQ,SAAS,OAAO,QAAQ,MAAM;AAC3F,cAAI;AACJ,eAAK,YAAY,MAAM;AACvB,iBAAO;AAAA;AAET,aAAK,YAAY,UAAU;AAC3B,eAAO;AAAA,aACF;AACL,eAAO;AAAA;AAAA;AAAA;AAIb,SAAO;AAAA,EACP;AAEF,IAAI,UAAU;AAAA,EACZ,UAAU,kBAAkB,IAAI,IAAI;AAClC,WAAO;AAAA,MACL,GAAG,GAAG,IAAI,GAAG;AAAA,MACb,GAAG,GAAG,IAAI,GAAG;AAAA;AAAA;AAAA,EAGjB,YAAY,oBAAoB,IAAI,IAAI;AACtC,WAAO,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG;AAAA;AAAA,EAEjC,QAAQ,gBAAgB,GAAG;AACzB,WAAO,KAAK,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE;AAAA;AAAA,EAEvC,OAAO,eAAe,GAAG,GAAG;AAC1B,WAAO;AAAA,MACL,GAAG,EAAE,IAAI;AAAA,MACT,GAAG,EAAE,IAAI;AAAA;AAAA;AAAA;AAIf,IAAI,eAAe;AACnB,IAAI,oBAAoB,KAAK,IAAI,GAAK,CAAC,eAAe;AACtD,2BAA2B,OAAO,OAAO;AACvC,MAAI,aAAa,IACb,IAAI,iBAAiB,OAAO,QAC5B,SAAS,MAAM,SAAS,GACxB,eAAe,IAAI,SAAS,GAC5B,eAAe,WAAW,GAAG,cAAc,YAAY,IACvD,IAAI,QAAQ,SAAS,OAAO,MAAM,KAClC,QAAO,QAAQ,OAAO,IACtB,IAAI,GACJ;AACJ,WAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACrC,QAAI,QAAQ,SAAS,OAAO,QAAQ,OAAO,QAAQ,WAAW,IAAI,MAAM;AACxE,cAAU,QAAQ,OAAO;AACzB,QAAI,UAAU,OAAM;AAClB,cAAO;AACP,UAAI,WAAW;AAAA;AAAA;AAGnB,MAAI,QAAQ,SAAS,OAAO,MAAM;AAClC,YAAU,QAAQ,OAAO;AACzB,MAAI,UAAU,OAAM;AAClB,YAAO;AACP,QAAI;AAAA;AAEN,SAAO;AAAA,IACL,UAAU;AAAA,IACV,UAAU;AAAA;AAAA;AAGd,6BAA6B,OAAO,OAAO;AACzC,MAAI,KAAK,kBAAkB,OAAO;AAClC,SAAO;AAAA,IACL,OAAO,QAAQ,OAAO,MAAM,SAAS,GAAG,GAAG,UAAU,MAAM;AAAA,IAC3D,UAAU,GAAG;AAAA;AAAA;AAGjB,0BAA0B,OAAO,OAAO;AACtC,MAAI,SAAS,MAAM,SAAS,GACxB,eAAe,IAAI,SAAS,GAC5B,IAAI,IACJ,IAAI,IACJ,UAAU,IACV,IAAI,IACJ,IAAI,CAAC,CAAC,GAAK,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,KAAK;AACrE,WAAS,IAAI,GAAG,KAAK,QAAQ,KAAK;AAChC,MAAE,KAAK,QAAQ,SAAS,MAAM,IAAI;AAAA;AAEpC,WAAS,KAAK,GAAG,MAAM,SAAS,GAAG,MAAM;AACvC,MAAE,MAAM,QAAQ,SAAS,MAAM,KAAK,IAAI,MAAM;AAC9C,MAAE,MAAM,QAAQ,MAAM,EAAE,KAAK;AAAA;AAE/B,WAAS,MAAM,GAAG,OAAO,SAAS,GAAG,OAAO;AAC1C,aAAS,SAAS,GAAG,UAAU,QAAQ,UAAU;AAC/C,UAAI,CAAC,QAAQ;AAAM,gBAAQ,OAAO;AAClC,cAAQ,KAAK,UAAU,QAAQ,WAAW,EAAE,MAAM,EAAE;AAAA;AAAA;AAGxD,WAAS,MAAM,GAAG,OAAO,cAAc,OAAO;AAC5C,QAAI,CAAC,EAAE,MAAM;AACX,QAAE,OAAO;AAAA;AAEX,MAAE,KAAK,IAAI;AACX,MAAE,KAAK,IAAI,WAAW,KAAK,OAAO;AAAA;AAEpC,MAAI,IAAI,QACJ,IAAI,SAAS;AACjB,WAAS,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK;AAC/B,QAAI,KAAK,KAAK,IAAI,GAAG,IAAI,IACrB,KAAK,KAAK,IAAI,GAAG;AACrB,aAAS,MAAM,IAAI,OAAO,IAAI,OAAO;AACnC,UAAI,IAAI,IAAI;AACZ,QAAE,MAAM,GAAG,KAAK,QAAQ,GAAG,OAAO,EAAE,GAAG;AAAA;AAAA;AAG3C,SAAO;AAAA;AAET,oBAAoB,GAAG,QAAQ,GAAG,OAAO;AACvC,MAAI,OAAO,IACP,QAAQ,IACR,YACA,aACA,SAAS,IACT,UAAU;AACd,UAAQ,kBAAkB,GAAG;AAAA,SACtB,GACH;AACE,aAAO;AAAA;AAAA,SAEN,GACH;AACE,UAAI,SAAS,cAAc;AACzB,UAAE,KAAM,GAAE,GAAG,IAAI,EAAE,QAAQ,KAAK;AAChC,eAAO;AAAA;AAET,UAAI,cAAc,GAAG,SAAS;AAC5B,UAAE,KAAK,mBAAmB,GAAG;AAC7B,eAAO;AAAA;AAET;AAAA;AAAA;AAGN,UAAQ,GAAG,QAAQ,KAAK,MAAM;AAC9B,eAAa,WAAW,MAAM,QAAQ,QAAQ,QAAQ;AACtD,gBAAc,WAAW,OAAO,QAAQ,SAAS,QAAQ;AACzD,WAAS,IAAI,GAAG,IAAI,YAAY,KAAK;AACnC,MAAE,KAAK,OAAO;AAAA;AAEhB,WAAS,MAAM,GAAG,MAAM,aAAa,OAAO;AAC1C,MAAE,MAAM,cAAc,QAAQ;AAAA;AAEhC,SAAO,aAAa;AAAA;AAEtB,2BAA2B,OAAO,QAAQ;AACxC,MAAI,cAAc,GACd,MACA;AACJ,SAAO,WAAW,IAAI,MAAM,GAAG;AAC/B,WAAS,IAAI,GAAG,KAAK,QAAQ,KAAK;AAChC,WAAO,IAAI,MAAM,GAAG;AACpB,QAAI,QAAQ;AAAU;AACtB,eAAW;AAAA;AAEb,SAAO;AAAA;AAET,uBAAuB,OAAO,QAAQ;AACpC,MAAI,OAAO,aAAa,aAAa,gBAAgB,iBAAiB,GAAG,GAAG,GAAG,KAAK,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI;AAC9G,MAAI,MAAM,GAAG,IAAI,MAAM,QAAQ;AAC/B,MAAI,MAAM,QAAQ,IAAI,MAAM,GAAG;AAC/B,MAAI,MAAM,GAAG,IAAI,MAAM,QAAQ,IAAI,MAAM,QAAQ,IAAI,MAAM,GAAG;AAC9D,MAAI,oBAAoB;AACxB,uBAAqB,qBAAqB;AAC1C,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,QAAI,QAAQ,IAAI,MAAM,GAAG,IAAI,IAAI,MAAM,GAAG,IAAI;AAC9C,QAAI,QAAQ,oBAAoB;AAC9B,2BAAqB;AAAA,eACZ,QAAQ,oBAAoB;AACrC,2BAAqB;AAAA;AAAA;AAGzB,OAAK;AACL,OAAK;AACL,OAAK;AACL,OAAK;AACL,OAAK;AACL,OAAK,IAAI;AACT,QAAM,KAAK,KAAK,KAAK;AACrB,SAAO,IAAM;AACb,gBAAe,MAAK,KAAK,KAAK,MAAM;AACpC,OAAK;AACL,OAAK;AACL,OAAK,IAAI;AACT,QAAM,KAAK,KAAK,KAAK;AACrB,SAAO,IAAM;AACb,gBAAe,MAAK,KAAK,KAAK,MAAM;AACpC,mBAAiB,KAAK,IAAI,aAAa;AACvC,oBAAkB,KAAK,IAAI,aAAa;AACxC,UAAQ,kBAAkB;AAC1B,SAAO,QAAQ,oBAAoB,IAAI;AAAA;AAEzC,4BAA4B,OAAO,QAAQ;AACzC,MAAI,MAAM,GACN,MAAM,GACN,MAAM,MAAM,QAAQ,IAAI,MAAM,GAAG,GACjC,MAAM,MAAM,QAAQ,IAAI,MAAM,GAAG,GACjC,MAAM,MAAM,GAAG,IAAI,GACnB,MAAM,MAAM,GAAG,IAAI,GACnB,MAAM,MAAM,MAAM,MAAM,KACxB,SAAS,IAAM,KACf,IAAK,OAAM,MAAM,MAAM,OAAO;AAClC,SAAO,IAAM,MAAM;AAAA;AAErB,iBAAiB,OAAO,QAAQ,GAAG,MAAM,OAAO;AAC9C,MAAI,OAAO,CAAC;AACZ,WAAS,IAAI,GAAG,KAAK,QAAQ,KAAK;AAChC,SAAK,GAAG,KAAK,MAAM;AAAA;AAErB,WAAS,IAAI,GAAG,KAAK,QAAQ,KAAK;AAChC,aAAS,KAAK,GAAG,MAAM,SAAS,GAAG,MAAM;AACvC,UAAI,CAAC,KAAK;AAAI,aAAK,KAAK;AACxB,UAAI,CAAC,KAAK,GAAG;AAAK,aAAK,GAAG,MAAM;AAChC,WAAK,GAAG,IAAI,IAAK,KAAM,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,IAAI,KAAK,IAAI,GAAG,KAAK,GAAG;AACxE,WAAK,GAAG,IAAI,IAAK,KAAM,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,IAAI,KAAK,IAAI,GAAG,KAAK,GAAG;AAAA;AAAA;AAG5E,MAAI,QAAQ,MAAM;AAChB,aAAS,MAAM,GAAG,OAAO,QAAQ,OAAO;AACtC,WAAK,OAAO,KAAK,KAAK;AAAA;AAAA;AAG1B,MAAI,SAAS,MAAM;AACjB,aAAS,MAAM,GAAG,OAAO,QAAQ,OAAO;AACtC,YAAM,OAAO,KAAK,SAAS,KAAK;AAAA;AAAA;AAGpC,SAAO,KAAK,QAAQ;AAAA;AAEtB,iBAAiB,OAAO,OAAO;AAC7B,MAAI,MAAM;AACV;AACA,WAAS,IAAI,GAAG,KAAK,OAAO,KAAK;AAC/B,QAAI,KAAK,eAAe,IAAI,OAAO;AAAA;AAErC,SAAO;AAAA;AAET,wBAAwB,GAAG,OAAO;AAChC,MAAI,cAAc;AAAA,IAChB,GAAG;AAAA,IACH,GAAG;AAAA;AAEL,MAAI,MAAM,GAAG;AACX,WAAO,MAAM;AAAA;AAEf,MAAI,SAAS,MAAM,SAAS;AAC5B,MAAI,MAAM,GAAG;AACX,WAAO,MAAM;AAAA;AAEf,MAAI,IAAI;AACR,MAAI,IAAI,IAAI;AACZ,MAAI,WAAW,GAAG;AAChB,WAAO,MAAM;AAAA;AAEf,MAAI,WAAW,GAAG;AAChB,WAAO;AAAA,MACL,GAAG,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG;AAAA,MACzB,GAAG,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG;AAAA;AAAA;AAG7B,MAAI,IAAI,QAAQ;AACd,QAAI,IAAI,IAAI,GACR,IAAI,IAAI,GACR,IAAI,GACJ,GACA,GACA;AACJ,QAAI,WAAW,GAAG;AAChB,UAAI,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI;AACvB,UAAI;AACJ,UAAI,IAAK,KAAI;AACb,UAAI;AAAA,eACK,WAAW,GAAG;AACvB,UAAI,IAAI;AACR,UAAI,IAAK,KAAI;AACb,UAAI,IAAK,KAAI;AACb,UAAI,IAAI;AAAA;AAEV,WAAO;AAAA,MACL,GAAG,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG;AAAA,MACnD,GAAG,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,GAAG;AAAA;AAAA,SAEhD;AACL,WAAO;AAAA;AAAA;AAGX,6BAA6B,OAAO;AAClC,MAAI,SAAS;AACb,MAAI,CAAC,QAAQ,QAAQ;AACnB,QAAI,QAAQ;AACZ,QAAI,MAAM,QAAQ,OAAO;AACzB,aAAS,IAAI,GAAG,IAAI,QAAQ,GAAG,KAAK;AAClC,UAAI,IAAI,IAAI,IACR,IAAI,IAAI,IAAI;AAChB,gBAAU,KAAK,GAAG;AAAA;AAAA;AAGtB,SAAO;AAAA;AAET,IAAI,sBAAsB,oBAAI;AAC9B,4BAA4B,OAAO;AACjC,MAAI,MAAM,oBAAoB,IAAI;AAClC,MAAI,CAAC,KAAK;AACR,UAAM;AACN,QAAI,SAAS,mBAAkB;AAC7B,aAAO,SAAU,GAAG;AAClB,eAAO,KAAK,IAAI,GAAG;AAAA;AAAA,OAGnB,SAAS,mBAAkB;AAC7B,aAAO,SAAU,GAAG;AAClB,eAAO,KAAK,IAAI,IAAI,GAAG;AAAA;AAAA,OAGvB,SAAS,iBAAgB,GAAG;AAC9B,aAAO,SAAU,GAAG;AAClB,eAAO;AAAA;AAAA,OAGP,SAAS,mBAAkB;AAC7B,aAAO,SAAU,GAAG;AAClB,eAAO;AAAA;AAAA,OAGP,mBAAmB,6BAA4B;AACjD,aAAO,SAAU,GAAG;AAClB,eAAO,IAAI;AAAA;AAAA,OAGX,YAAY,oBAAmB,QAAO;AACxC,aAAO,SAAU,GAAG;AAClB,YAAI,IAAI;AACR,iBAAS,KAAI,GAAG,KAAI,OAAM,QAAQ,MAAK;AACrC,cAAI,IAAI,OAAM,IAAG;AAAA;AAEnB,eAAO;AAAA;AAAA;AAGX,QAAI,KAAK;AACT,aAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC9B,UAAI,QAAQ,CAAC,OAAO;AACpB,eAAS,IAAI,GAAG,IAAI,QAAQ,GAAG,KAAK;AAClC,cAAM,KAAK;AAAA;AAEb,eAAS,MAAM,GAAG,MAAM,GAAG,OAAO;AAChC,cAAM,KAAK;AAAA;AAEb,UAAI,KAAK,UAAU;AAAA;AAErB,QAAI,KAAK;AACT,wBAAoB,IAAI,OAAO;AAAA;AAEjC,SAAO;AAAA;AAET,sBAAsB,OAAO,UAAU;AACrC,MAAI,KAAK,mBAAmB,MAAM,SAAS,IACvC,KAAK,GACL,KAAK;AACT,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,SAAK,KAAK,MAAM,GAAG,IAAI,GAAG,GAAG;AAC7B,SAAK,KAAK,MAAM,GAAG,IAAI,GAAG,GAAG;AAAA;AAE/B,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA;AAAA;AAGP,cAAc,IAAI,IAAI;AACpB,SAAO,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG;AAAA;AAEpE,iBAAiB,OAAO;AACtB,SAAO,MAAM,GAAG,MAAM,MAAM,GAAG,KAAK,MAAM,GAAG,MAAM,MAAM,GAAG;AAAA;AAE9D,wBAAwB,OAAO,UAAU,UAAU;AACjD,MAAI,QAAQ,QAAQ;AAClB,WAAO;AAAA,MACL,OAAO,MAAM;AAAA,MACb;AAAA;AAAA;AAGJ,MAAI,OAAO,aAAa,OAAO,WAC3B,QAAQ,GACR,SAAS,UACT,YAAY,WAAW,IAAI,IAAI,IAC/B,MAAM;AACV,SAAO,QAAQ,KAAK,IAAI,WAAW;AACjC,cAAU,OAAQ;AAClB,UAAM,aAAa,OAAO;AAC1B,aAAS,KAAK,KAAK;AACnB,WAAO;AAAA;AAET,SAAO;AAAA,IACL,OAAO;AAAA,IACP,UAAU;AAAA;AAAA;AAGd,6BAA6B,OAAO,UAAU,UAAU;AACtD,SAAO,eAAe,OAAO,UAAU,UAAU;AAAA;AAEnD,gCAAgC,OAAO,UAAU,UAAU;AACzD,SAAO,eAAe,OAAO,UAAU,UAAU;AAAA;AAEnD,yBAAyB,OAAO,UAAU;AACxC,MAAI,KAAK,aAAa,OAAO,WACzB,KAAK,aAAa,MAAM,MAAM,GAAG,MAAM,SAAS,IAAI,WACpD,KAAK,GAAG,IAAI,GAAG,GACf,KAAK,GAAG,IAAI,GAAG;AACnB,SAAO,OAAO,IAAI,WAAW,KAAK,KAAK,KAAK;AAAA;AAE9C,sCAAsC,OAAO,UAAU,UAAU;AAC/D,MAAI,IAAI,eAAe,OAAO,UAAU;AACxC,MAAI,EAAE,WAAW;AAAG,MAAE,WAAW;AACjC,MAAI,EAAE,WAAW;AAAG,MAAE,WAAW;AACjC,SAAO,gBAAgB,OAAO,EAAE;AAAA;AAElC,+BAA+B,OAAO,UAAU,QAAQ,UAAU;AAChE,aAAW,YAAY,OAAO,IAAI;AAClC,MAAI,IAAI,eAAe,OAAO,UAAU,WACpC,IAAI,gBAAgB,OAAO,EAAE,WAC7B,UAAU,KAAK,KAAK,KAAK,IACzB,IAAI,SAAS,IAAI,KAAK,IAAI,UAC1B,IAAI,SAAS,IAAI,KAAK,IAAI;AAC9B,SAAO,CAAC;AAAA,IACN,GAAG,EAAE,MAAM,IAAI;AAAA,IACf,GAAG,EAAE,MAAM,IAAI;AAAA,KACd;AAAA,IACD,GAAG,EAAE,MAAM,IAAI;AAAA,IACf,GAAG,EAAE,MAAM,IAAI;AAAA;AAAA;AAGnB,gCAAgC,IAAI,IAAI,IAAI,IAAI,OAAO;AACrD,MAAI,IAAI,KAAK,IACT,IAAI,KAAK,IACT,IAAI,KAAM,MAAK,MAAM,KAAM,MAAK,KAChC,SAAS,qBAAqB,QAC9B,IAAI,CAAC,IAAI,OAAO,GAAG,KAAK,IAAI,OAAO,GAAG,IAAI,IAAI,OAAO,GAAG,KAAK,IAAI,OAAO,GAAG,IAAI,IAAI,OAAO,GAAG,KAAK,IAAI,OAAO,GAAG,IAAI,IAAI,OAAO,GAAG,KAAK,IAAI,OAAO,GAAG,KAAK,IAC1J,IAAI,YAAY,MAAM,MAAM,IAC5B,gBAAgB;AACpB,MAAI,KAAK,MAAM;AACb,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,UAAI,KAAK,EAAE,IACP,KAAK,KAAK,IAAI,IAAI,IAClB,KAAK,KAAK,IAAI,IAAI,IAClB,IAAI;AAAA,QACN,GAAG,OAAO,GAAG,KAAK,KAAK,OAAO,GAAG,KAAK,KAAK,OAAO,GAAG,KAAK,KAAK,OAAO,GAAG;AAAA,QACzE,GAAG,OAAO,GAAG,KAAK,KAAK,OAAO,GAAG,KAAK,KAAK,OAAO,GAAG,KAAK,KAAK,OAAO,GAAG;AAAA;AAE3E,UAAI,IAAI;AACR,UAAI,KAAK,OAAO,GAAG;AACjB,YAAK,GAAE,KAAK,MAAO,MAAK;AAAA,aACnB;AACL,YAAK,GAAE,KAAK,MAAO,MAAK;AAAA;AAE1B,UAAI,MAAM,KAAK,MAAM,KAAO,KAAK,KAAK,KAAK,GAAK;AAC9C,sBAAc,KAAK;AAAA;AAAA;AAAA;AAIzB,SAAO;AAAA;AAET,yBAAyB,GAAG,GAAG,GAAG,GAAG,OAAO;AAC1C,MAAI,IAAI;AACR,IAAE,KAAK,MAAM,GAAG,uBAAuB,GAAG,GAAG,IAAI,GAAG,GAAG;AACvD,IAAE,KAAK,MAAM,GAAG,uBAAuB,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG;AAC/D,IAAE,KAAK,MAAM,GAAG,uBAAuB,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG;AAC/D,IAAE,KAAK,MAAM,GAAG,uBAAuB,GAAG,IAAI,GAAG,GAAG,GAAG;AACvD,SAAO;AAAA;AAET,iCAAiC,aAAa,OAAO;AACnD,MAAI,IAAI;AACR,IAAE,KAAK,MAAM,GAAG,uBAAuB,YAAY,GAAG,YAAY,GAAG,YAAY,IAAI,YAAY,GAAG,YAAY,GAAG;AACnH,IAAE,KAAK,MAAM,GAAG,uBAAuB,YAAY,IAAI,YAAY,GAAG,YAAY,GAAG,YAAY,IAAI,YAAY,GAAG,YAAY,IAAI,YAAY,GAAG;AACnJ,IAAE,KAAK,MAAM,GAAG,uBAAuB,YAAY,IAAI,YAAY,GAAG,YAAY,IAAI,YAAY,GAAG,YAAY,GAAG,YAAY,IAAI,YAAY,GAAG;AACnJ,IAAE,KAAK,MAAM,GAAG,uBAAuB,YAAY,GAAG,YAAY,IAAI,YAAY,GAAG,YAAY,GAAG,YAAY,GAAG;AACnH,SAAO;AAAA;AAET,qCAAqC,OAAO,MAAM;AAChD,SAAO,CAAC,CAAC,MAAM,GAAG,QAAQ,IAAI,MAAM,GAAG,QAAQ,KAAK,MAAM,GAAG,QAAQ,MAAM,GAAG,OAAO,IAAI,MAAM,GAAG,QAAQ,IAAI,MAAM,GAAG,QAAQ,IAAI,MAAM,GAAG,OAAO,KAAK,MAAM,GAAG,QAAQ,IAAI,MAAM,GAAG,OAAO,MAAM,GAAG;AAAA;AAExM,8BAA8B,OAAO;AACnC,SAAO,CAAC,4BAA4B,OAAO,MAAM,4BAA4B,OAAO;AAAA;AAEtF,aAAa,GAAG;AACd,SAAO,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI;AAAA;AAElC,qBAAqB,GAAG,GAAG,GAAG,GAAG;AAC/B,MAAI,IAAI,IAAI,GACR,IAAI,IAAI,GACR,IAAI,IAAI,GACR,IAAK,KAAI,IAAI,KAAK,IAAI,GAAG,MAAM,GAC/B,IAAK,KAAI,IAAI,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,GAAG,MAAM,IAChD,IAAI,KAAK,IAAI,GAAG,KAAK,KAAK,IAAI,GAAG,IACjC,GACA,GACA,IAAI,CAAC,GAAG,GAAG;AACf,MAAI,KAAK,GACP;AACE,QAAI,IAAI,IAAI,KAAK,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI;AACrE,QAAI,IAAI,IAAI,KAAK,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI;AACrE,MAAE,KAAK,CAAC,IAAI,IAAK,KAAI;AACrB,MAAE,KAAK,CAAC,IAAI,IAAK,KAAI,KAAK;AAC1B,MAAE,KAAK,CAAC,IAAI,IAAK,KAAI,KAAK;AAC1B,QAAI,KAAK,IAAI,KAAK,KAAK,KAAM,KAAI,KAAK,OAAO,GAAG;AAC9C,QAAE,KAAK;AACP,QAAE,KAAK;AAAA;AAAA,SAGX;AACE,QAAI,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK,CAAC,KAAK,IAAI,GAAG;AAC9C,MAAE,KAAK,IAAI,KAAK,KAAK,CAAC,KAAK,KAAK,IAAI,KAAK,KAAK,IAAI;AAClD,MAAE,KAAK,IAAI,KAAK,KAAK,CAAC,KAAK,KAAK,IAAK,MAAK,IAAI,KAAK,MAAM,KAAK,IAAI;AAClE,MAAE,KAAK,IAAI,KAAK,KAAK,CAAC,KAAK,KAAK,IAAK,MAAK,IAAI,KAAK,MAAM,KAAK,IAAI;AAAA;AAEtE,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,QAAI,EAAE,KAAK,KAAK,EAAE,KAAK,GAAK;AAC1B,QAAE,KAAK;AAAA;AAAA;AAGX,SAAO;AAAA;AAGN,IAAC,gBAAgB,SAAU,kBAAkB;AAC9C,YAAU,gBAAe;AACzB,MAAI,SAAS,aAAa;AAC1B,0BAAuB,QAAQ;AAC7B,QAAI;AACJ,oBAAgB,MAAM;AACtB,YAAQ,OAAO,KAAK,MAAM;AAC1B,oBAAgB,uBAAuB,QAAQ,SAAS;AACxD,oBAAgB,uBAAuB,QAAQ,QAAQ;AACvD,oBAAgB,uBAAuB,QAAQ,QAAQ;AACvD,oBAAgB,uBAAuB,QAAQ,QAAQ;AACvD,oBAAgB,uBAAuB,QAAQ,QAAQ;AACvD,oBAAgB,uBAAuB,QAAQ,UAAU;AACzD,oBAAgB,uBAAuB,QAAQ,QAAQ,eAAc;AACrE,UAAM,OAAO,OAAO;AACpB,UAAM,OAAO,OAAO;AACpB,UAAM,OAAO,OAAO;AACpB,UAAM,OAAO,OAAO;AACpB,UAAM,KAAK,OAAO;AAClB,UAAM,KAAK,OAAO;AAClB,UAAM,KAAK,OAAO;AAClB,UAAM,KAAK,OAAO;AAClB,UAAM,QAAQ,CAAC;AAAA,MACb,GAAG,MAAM;AAAA,MACT,GAAG,MAAM;AAAA,OACR;AAAA,MACD,GAAG,MAAM;AAAA,MACT,GAAG,MAAM;AAAA,OACR;AAAA,MACD,GAAG,MAAM;AAAA,MACT,GAAG,MAAM;AAAA,OACR;AAAA,MACD,GAAG,MAAM;AAAA,MACT,GAAG,MAAM;AAAA;AAEX,UAAM,UAAU;AAAA,MACd,MAAM,KAAK,IAAI,MAAM,IAAI,MAAM,IAAI,MAAM,MAAM,MAAM;AAAA,MACrD,MAAM,KAAK,IAAI,MAAM,IAAI,MAAM,IAAI,MAAM,MAAM,MAAM;AAAA,MACrD,MAAM,KAAK,IAAI,MAAM,IAAI,MAAM,IAAI,MAAM,MAAM,MAAM;AAAA,MACrD,MAAM,KAAK,IAAI,MAAM,IAAI,MAAM,IAAI,MAAM,MAAM,MAAM;AAAA;AAEvD,WAAO;AAAA;AAET,eAAa,gBAAe,CAAC;AAAA,IAC3B,KAAK;AAAA,IACL,OAAO,iBAAiB,gBAAgB;AACtC,aAAQ,kBAAiB,OAAO,KAAK,KAAK,MAAM,KAAK,KAAK,MAAM,MAAM,OAAO,KAAK,OAAO,MAAM,KAAK,OAAO,MAAM,KAAK,OAAO,MAAM,KAAK,OAAO,MAAM,KAAK,KAAK,MAAM,KAAK;AAAA;AAAA,KAE3K;AAAA,IACD,KAAK;AAAA,IACL,OAAO,qBAAqB,UAAU,UAAU;AAC9C,iBAAW,eAAc,mBAAmB,KAAK,OAAO,UAAU;AAClE,aAAO,aAAa,KAAK,OAAO;AAAA;AAAA,KAEjC;AAAA,IACD,KAAK;AAAA,IACL,OAAO,2BAA2B,UAAU,UAAU;AACpD,iBAAW,eAAc,mBAAmB,KAAK,OAAO,UAAU;AAClE,aAAO,gBAAgB,KAAK,OAAO;AAAA;AAAA,KAEpC;AAAA,IACD,KAAK;AAAA,IACL,OAAO,4BAA4B,UAAU,UAAU,UAAU;AAC/D,iBAAW,eAAc,mBAAmB,KAAK,OAAO,UAAU;AAClE,aAAO,oBAAoB,KAAK,OAAO,UAAU;AAAA;AAAA,KAElD;AAAA,IACD,KAAK;AAAA,IACL,OAAO,qBAAqB;AAC1B,UAAI,KAAK,UAAU,QAAQ,KAAK,WAAW,GAAG;AAC5C,aAAK,SAAS,oBAAoB,KAAK;AAAA;AAEzC,aAAO,KAAK;AAAA;AAAA,KAEb;AAAA,IACD,KAAK;AAAA,IACL,OAAO,gCAAgC,GAAG,GAAG;AAC3C,UAAI,IAAI,oBAAoB;AAAA,QAC1B;AAAA,QACA;AAAA,SACC,KAAK;AACR,aAAO;AAAA,QACL,GAAG,KAAK,KAAK,KAAK,IAAI,EAAE,MAAM,IAAI,GAAG,KAAK,KAAK,IAAI,EAAE,MAAM,IAAI,GAAG;AAAA,QAClE,GAAG,EAAE,MAAM;AAAA,QACX,GAAG,EAAE,MAAM;AAAA,QACX,GAAG,IAAI,EAAE;AAAA,QACT,GAAG;AAAA,QACH,IAAI;AAAA,QACJ,IAAI;AAAA,QACJ,IAAI;AAAA,QACJ,IAAI;AAAA;AAAA;AAAA,KAGP;AAAA,IACD,KAAK;AAAA,IACL,OAAO,0BAA0B,IAAI,IAAI,IAAI,IAAI;AAC/C,aAAO,uBAAuB,IAAI,IAAI,IAAI,IAAI,KAAK;AAAA;AAAA,MAEnD,CAAC;AAAA,IACH,KAAK;AAAA,IACL,OAAO,4BAA4B,QAAQ,UAAU,UAAU;AAC7D,UAAI,UAAU;AACZ,mBAAW,uBAAuB,QAAQ,WAAW,IAAI,IAAI,GAAG;AAAA;AAElE,aAAO;AAAA;AAAA;AAGX,SAAO;AAAA,EACP;AACF,gBAAgB,eAAe,eAAe;AAE3C,IAAC,kBAAkB,SAAU,uBAAuB;AACrD,YAAU,kBAAiB;AAC3B,MAAI,SAAS,aAAa;AAC1B,4BAAyB,YAAY,QAAQ;AAC3C,QAAI;AACJ,oBAAgB,MAAM;AACtB,YAAQ,OAAO,KAAK,MAAM,YAAY;AACtC,UAAM,aAAa;AACnB,oBAAgB,uBAAuB,QAAQ,QAAQ,iBAAgB;AACvE,oBAAgB,uBAAuB,QAAQ,eAAe;AAC9D,oBAAgB,uBAAuB,QAAQ,eAAe;AAC9D,aAAS,UAAU;AACnB,UAAM,cAAc,OAAO,aAAa;AACxC,UAAM,cAAc;AACpB,WAAO;AAAA;AAET,eAAa,kBAAiB,CAAC;AAAA,IAC7B,KAAK;AAAA,IACL,OAAO,wBAAwB;AAC7B,aAAO,KAAK;AAAA;AAAA,KAEb;AAAA,IACD,KAAK;AAAA,IACL,OAAO,4BAA2B,OAAO,sBAAsB,sBAAsB,KAAK,KAAK;AAC7F,UAAI,gBAAgB,IAAI,OAAO,IAAI,MAAM,IAAI,OAAO,IAAI,IACpD,IAAI;AAAA,QACN,GAAG;AAAA,QACH,GAAG;AAAA;AAEL,UAAI,CAAC,eAAe;AAClB,YAAI,IAAI,OAAO,GAAG;AAChB,YAAE,IAAI,qBAAqB,OAAO,qBAAqB,OAAO,MAAM,IAAI,KAAK,cAAc,MAAM,IAAI,KAAK;AAAA,eACrG;AACL,YAAE,IAAI,MAAM,IAAI,KAAK,cAAc,IAAI;AAAA;AAEzC,YAAI,IAAI,OAAO,GAAG;AAChB,YAAE,IAAI,qBAAqB,OAAO,qBAAqB,OAAO,MAAM,IAAI,KAAK,cAAc,MAAM,IAAI,KAAK;AAAA,eACrG;AACL,YAAE,IAAI,MAAM,IAAI,KAAK,cAAc,IAAI;AAAA;AAAA,aAEpC;AACL,YAAI,IAAI,OAAO,GAAG;AAChB,YAAE,IAAI,qBAAqB,OAAO,qBAAqB,OAAO,MAAM,IAAI,KAAK,cAAc,MAAM,IAAI,KAAK;AAAA,eACrG;AACL,YAAE,IAAI,MAAM,IAAI,KAAK,cAAc,IAAI;AAAA;AAEzC,YAAI,IAAI,OAAO,GAAG;AAChB,YAAE,IAAI,qBAAqB,OAAO,qBAAqB,OAAO,MAAM,IAAI,KAAK,cAAc,MAAM,IAAI,KAAK;AAAA,eACrG;AACL,YAAE,IAAI,MAAM,IAAI,KAAK,cAAc,IAAI;AAAA;AAAA;AAG3C,aAAO;AAAA;AAAA,KAER;AAAA,IACD,KAAK;AAAA,IACL,OAAO,wBAAwB,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI;AAC3D,UAAI,KACA,MACA,MAAM,GAAG,OAAO,GAAG,OAAO,KAAK,GAC/B,MAAM,GAAG,OAAO,GAAG,OAAO,KAAK,GAC/B,MAAM,GAAG,OAAO,GAAG,OAAO,IAAI,IAC9B,MAAM,GAAG,OAAO,GAAG,OAAO,IAAI;AAClC,UAAI,KAAK,WAAW,MAAM;AACxB,cAAM,KAAK,kBAAkB;AAAA,UAC3B,GAAG;AAAA,UACH,GAAG;AAAA,WACF,IAAI,IAAI,UAAU,IAAI,UAAU;AACnC,eAAO,KAAK,kBAAkB;AAAA,UAC5B,GAAG;AAAA,UACH,GAAG;AAAA,WACF,IAAI,IAAI,UAAU,IAAI,UAAU;AAAA,aAC9B;AACL,cAAM,KAAK,SAAS,cAAc;AAClC,eAAO,KAAK,SAAS,cAAc;AAAA;AAErC,WAAK,WAAW;AAAA,QACd,eAAe,CAAC,KAAK;AAAA,QACrB,QAAQ,EAAE;AAAA,QACV,QAAQ,EAAE;AAAA;AAEZ,WAAK,YAAY,eAAe;AAAA,QAC9B,IAAI;AAAA,QACJ,IAAI;AAAA,QACJ,IAAI;AAAA,QACJ,IAAI;AAAA,QACJ,MAAM,IAAI;AAAA,QACV,MAAM,IAAI;AAAA,QACV,MAAM,KAAK;AAAA,QACX,MAAM,KAAK;AAAA;AAAA;AAAA;AAIjB,SAAO;AAAA,EACP;AACF,gBAAgB,iBAAiB,QAAQ;AAEzC,kBAAkB,IAAI,IAAI,IAAI,IAAI;AAChC,MAAI,MAAM,MAAM,MAAM,IAAI;AACxB,WAAO;AAAA,aACE,MAAM,MAAM,MAAM,IAAI;AAC/B,WAAO;AAAA,aACE,MAAM,MAAM,MAAM,IAAI;AAC/B,WAAO;AAAA;AAET,SAAO;AAAA;AAET,2BAA2B,MAAM,MAAM,SAAS,YAAY,YAAY,IAAI,IAAI,UAAU,gBAAgB;AACxG,MAAI,YAAY,gBAAgB;AAC9B,WAAO;AAAA,MACL,GAAG;AAAA,MACH,GAAG;AAAA;AAAA;AAGP,MAAI,YAAY,GAAG;AACjB,QAAI,WAAW,QAAQ,KAAK,WAAW,QAAQ,GAAG;AAChD,aAAO;AAAA,QACL,GAAG,OAAQ,YAAW,IAAI,MAAM,KAAK,KAAK;AAAA,QAC1C,GAAG;AAAA;AAAA,eAEI,WAAW,QAAQ,KAAK,WAAW,QAAQ,GAAG;AACvD,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG,OAAQ,YAAW,IAAI,MAAM,KAAK,KAAK;AAAA;AAAA,WAEvC;AACL,aAAO;AAAA,QACL,GAAG,OAAO,KAAK;AAAA,QACf,GAAG,OAAO,KAAK;AAAA;AAAA;AAAA,aAGV,YAAY,GAAG;AACxB,QAAI,WAAW,QAAQ,KAAK,WAAW,QAAQ,GAAG;AAChD,aAAO;AAAA,QACL,GAAG,OAAQ,YAAW,IAAI,MAAM,KAAK,KAAK;AAAA,QAC1C,GAAG;AAAA;AAAA,eAEI,WAAW,QAAQ,KAAK,WAAW,QAAQ,GAAG;AACvD,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG,OAAQ,YAAW,IAAI,MAAM,KAAK,KAAK;AAAA;AAAA,WAEvC;AACL,aAAO;AAAA,QACL,GAAG,OAAO;AAAA,QACV,GAAG,OAAO,KAAK;AAAA;AAAA;AAAA,aAGV,YAAY,GAAG;AACxB,QAAI,WAAW,QAAQ,KAAK,WAAW,QAAQ,GAAG;AAChD,aAAO;AAAA,QACL,GAAG,OAAQ,YAAW,IAAI,MAAM,KAAK,KAAK;AAAA,QAC1C,GAAG;AAAA;AAAA,eAEI,WAAW,QAAQ,KAAK,WAAW,QAAQ,GAAG;AACvD,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG,OAAQ,YAAW,IAAI,MAAM,KAAK,KAAK;AAAA;AAAA,WAEvC;AACL,aAAO;AAAA,QACL,GAAG,OAAO,KAAK;AAAA,QACf,GAAG,OAAO,KAAK;AAAA;AAAA;AAAA,aAGV,YAAY,GAAG;AACxB,QAAI,WAAW,QAAQ,KAAK,WAAW,QAAQ,GAAG;AAChD,aAAO;AAAA,QACL,GAAG,OAAQ,YAAW,IAAI,MAAM,KAAK,KAAK;AAAA,QAC1C,GAAG;AAAA;AAAA,eAEI,WAAW,QAAQ,KAAK,WAAW,QAAQ,GAAG;AACvD,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG,OAAQ,YAAW,IAAI,MAAM,KAAK,KAAK;AAAA;AAAA,WAEvC;AACL,aAAO;AAAA,QACL,GAAG,OAAO;AAAA,QACV,GAAG,OAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAKpB,IAAC,wBAAwB,SAAU,uBAAuB;AAC3D,YAAU,wBAAuB;AACjC,MAAI,SAAS,aAAa;AAC1B,kCAA+B,YAAY,QAAQ;AACjD,QAAI;AACJ,oBAAgB,MAAM;AACtB,YAAQ,OAAO,KAAK,MAAM,YAAY;AACtC,UAAM,aAAa;AACnB,oBAAgB,uBAAuB,QAAQ,QAAQ,uBAAsB;AAC7E,oBAAgB,uBAAuB,QAAQ,iBAAiB;AAChE,oBAAgB,uBAAuB,QAAQ,kBAAkB;AACjE,UAAM,YAAY,OAAO,aAAa;AACtC,UAAM,SAAS,OAAO,UAAU;AAChC,UAAM,iBAAiB,OAAO,kBAAkB;AAChD,UAAM,YAAY,OAAO,eAAe,OAAO,gBAAgB;AAC/D,WAAO;AAAA;AAET,eAAa,wBAAuB,CAAC;AAAA,IACnC,KAAK;AAAA,IACL,OAAO,wBAAwB,WAAW,QAAQ,IAAI,IAAI,GAAG,GAAG;AAC9D,UAAI,MAAM,GAAG,OAAO,GAAG,OAAO,IAAI,GAC9B,MAAM,GAAG,OAAO,GAAG,OAAO,IAAI,GAC9B,MAAM,GAAG,OAAO,GAAG,OAAO,IAAI,GAC9B,MAAM,GAAG,OAAO,GAAG,OAAO,IAAI;AAClC,UAAI,GAAG,MAAM,GAAG;AACd,eAAO,KAAK;AAAA;AAEd,UAAI,GAAG,MAAM,GAAG;AACd,eAAO,KAAK;AAAA;AAEd,UAAI,GAAG,MAAM,GAAG;AACd,eAAO,KAAK;AAAA;AAEd,UAAI,GAAG,MAAM,GAAG;AACd,eAAO,KAAK;AAAA;AAEd,UAAI,GAAG,MAAM,GAAG;AACd,eAAO,KAAK;AAAA;AAEd,UAAI,GAAG,MAAM,GAAG;AACd,eAAO,KAAK;AAAA;AAEd,UAAI,GAAG,MAAM,GAAG;AACd,eAAO,KAAK;AAAA;AAEd,UAAI,GAAG,MAAM,GAAG;AACd,eAAO,KAAK;AAAA;AAEd,UAAI,KAAK,WAAW,MAAM;AACxB,YAAI,QAAS,OAAM,OAAO,GACtB,QAAS,OAAM,OAAO,GACtB,UAAU,SAAS,KAAK,KAAK,KAAK,MAClC,WAAW,KAAK,KAAK,KAAK,IAAI,MAAM,KAAK,KAAK,KAAK,IAAI,MAAM,KAAK;AACtE,aAAK,gBAAgB,kBAAkB,OAAO,OAAO,SAAS,OAAO,WAAW,OAAO,WAAW,KAAK,WAAW,KAAK,WAAW,UAAU,KAAK;AAAA,aAC5I;AACL,aAAK,gBAAgB,KAAK,SAAS,cAAc;AAAA;AAEnD,UAAI,MAAM,MAAM,MAAM;AACtB,aAAO,KAAK,cAAc;AAC1B,aAAO,KAAK,cAAc;AAC1B,aAAO,KAAK,cAAc;AAC1B,aAAO,KAAK,cAAc;AAC1B,WAAK,WAAW;AAAA,QACd,eAAe,CAAC,KAAK,eAAe,KAAK;AAAA,QACzC,QAAQ,OAAO;AAAA,QACf,QAAQ,OAAO;AAAA;AAEjB,WAAK,YAAY,eAAe;AAAA,QAC9B,IAAI;AAAA,QACJ,IAAI;AAAA,QACJ,IAAI;AAAA,QACJ,IAAI;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA;AAAA;AAIN,SAAO;AAAA,EACP;AACF,gBAAgB,uBAAuB,QAAQ;AAE/C,WAAW,SAAS,gBAAgB,MAAM;AAC1C,WAAW,SAAS,sBAAsB,MAAM;;"}